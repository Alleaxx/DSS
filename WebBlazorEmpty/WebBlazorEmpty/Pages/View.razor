@page "/view"
@inherits DSSComponent
@layout EditorLayout


<style>
    .basic-border {
        border: 1px solid gainsboro;
        border-radius: 3px;
        margin: 3px;
        padding: 5px;
    }

    .info-sheme {
        flex-basis: 20%;
        max-width: 350px;
    }

    .sheme {
        flex-basis: 80%;
    }



    .col-own {
        display: flex;
        flex-direction: column;
    }

    .row-own {
        display: flex;
        flex-direction: row;
        justify-content: initial;
    }

    .level {
        align-items: center;
        border: 1px solid gainsboro;
    }



    .space-between {
        justify-content: space-between;
    }


    .level-name {
        width: 20%;
        text-align: center;
    }

    .level-elements {
        display: flex;
        flex-direction: row;
        width: 100%;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
    }

    .node-element {
        padding: 10px;
        margin: 10px;
        border: 1px solid gray;
        text-align: center;
        border-radius: 4px;

        text-decoration: none;
    }

        .node-element ol {
            list-style: none;
        }
        .node-element:hover{
            cursor: pointer;
            text-decoration: underline;
        }

    .filters {
        list-style: none;
        display: flex;
    }

        .filters li {
            padding: 5px 15px;
            border-bottom: 1px solid gainsboro;
        }

            .filters li:hover {
                background-color: gainsboro;
                cursor: pointer;
            }

    .selected {
        background-color: gainsboro;
    }


    .good {
        background-color: lightgreen;
    }


    .good-g a {
        color: green;
    }

    .bad {
        background-color: lightpink;
    }

    .warn{
        background-color: antiquewhite;
    }

    .bad-b a {
        color: orangered;
    }

    .best {
        background-color: lightgreen;
    }

    .sheme-header{
        display: flex;
        flex-direction: row;
        align-items: center;
    }

    .node-element a{
        text-decoration: none;
        color: black;
    }
</style>

<section>
    <div>
        <h2 class="content-header-h">Схема задачи выбора</h2>
        <ul class="filters">
            @foreach (var filter in Filters)
            {
                <li class="@(filter == Filter ? "selected" : "") " @onclick="@(() => Select(filter))">
                    @filter
                </li>
            }
        </ul>
    </div>
    @foreach (var levelGroup in Problem.GroupedByLevel)
    {
        <div class="row-own level">
            <div class="level-name">
                <span style="font-size:1.05em">Уровень @levelGroup.Key</span>
                <br>
                <span style="font-size:1.15em">@(HierarchyNodes.GetTextInfo(Problem,levelGroup.Key))</span>
            </div>
            <div class="level-elements">
                @foreach (var node in levelGroup)
                {
                    <a class="node-element @(GetTag(node).Class)" href="@(GetLink(node))" style="width:@NodeSize%">
                        <span>@node.Name</span>
                        <br />
                        <span style="font-size:0.9em; color: gray"> @(GetTag(node).Text)</span>
                        @if (Filter == Relations && node.Level != 0)
                        {
                            <ol>
                                @foreach (var rel in Problem.RelationsAll.Where(r => r.From == node && r.To != node))
                                {
                                    <li style="font-size: 0.8em" class="@(!Problem.CorrectnessRels.RelationsNotConsistent.Contains(rel) ? "good-g" : "bad-b")">
                                        <NavLink href="@($"relation/{GetIndexOf(rel)}")">
                                            [@(Math.Round(rel.Value,2))] @rel.Main.Name - @rel.To.Name
                                        </NavLink>
                                    </li>
                                }
                            </ol>
                        }
                    </a>
                }
            </div>
        </div>
    }
</section>

<div class="row-own">
    @*<section>
        <h4>Отображение</h4>
        <p>
            Размер узлов:
            <input type="number" @bind-value="@NodeSize" />
        </p>
    </section>*@

    <section>
        @if (Filter == Constistency)
        {
            <ViewConsistency />
        }
        else if (Filter == Description)
        {

        }
        else if (Filter == FilterRating)
        {
            <ViewRating />
        }
        else if (Filter == Relations)
        {
            <ViewRelations />
        }
    </section>
    @*<section>
        <ViewJson />
    </section>*@

</div>



@code {
    private int NodeSize { get; set; } = 20;



    const string Description = "По описанию";
    const string FilterRating = "По рейтингу критериев";
    const string Constistency = "По согласованности отношений";
    const string Relations = "По связанным отношениям";


    public string[] Filters { get; set; } = new string[]
    {
            FilterRating,
            Constistency,
        };
    private string Filter
    {
        get => Project.ViewFilter;
        set
        {
            Project.ViewFilter = value;
        }
    }


    private void Select(string text)
    {
        Filter = text;
    }


    private string GetLink(INode node)
    {
        INodeRelation rel = null;
        if (Problem.NodesWithRels.Contains(node))
        {
            rel = Problem.RelationsRequired.Where(r => r.Main == node).First();
        }


        if (rel == null)
            return $"/node/{node.Level}/{node.Name}";
        else
            return $"/relation-new/{GetIndexOf(rel)}";

    }
    private Tag GetTag(INode node)
    {
        Tag info = new Tag("", "usual");
        switch (Filter)
        {
            case FilterRating:
                string style = "usual";
                if (Problem.Best(node.Level).Contains(node))
                    style = "best";


                return new Tag($"{Math.Round(node.Coefficient, 5)}", style);
            case Constistency:
                double res = Problem.GetMatrix(node).Consistency.Cr;
                if (Problem.RelationsRequired.Where(r => r.Main == node && r.Unknown).Count() > 0)
                    return new Tag("-", "warn");

                if (double.IsNaN(res))
                    return new Tag("~", "good");
                else if (res >= MatrixConsistenct.BorderConsistenct)
                    return new Tag($"{Math.Round(res, 5)}", "bad");
                else
                    return new Tag($"{Math.Round(res, 5)}", "good");
            case Relations:
                return new Tag($"{Problem.RelationsRequired.Where(r => r.From == node).Count()}", "usual");
            case Description:
                return new Tag(node.Description, "");
            default:
                return info;
        }
    }




    private int GetIndexOf(INodeRelation rel) => Problem.RelationsAll.ToList().IndexOf(rel);

    class Tag
    {
        public string Text { get; set; }
        public string Class { get; set; }

        public Tag(string text, string style)
        {
            Text = text;
            Class = style;
        }
    }
}
